<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>测试Fluid样式</title>
    <link href="/2023/07/13/%E6%B5%8B%E8%AF%95Fluid%E6%A0%B7%E5%BC%8F/"/>
    <url>/2023/07/13/%E6%B5%8B%E8%AF%95Fluid%E6%A0%B7%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><div class="note note-success">            <p>文字</p>          </div><div class="note note-info">            <p>文字</p>          </div>]]></content>
    
    
    
    <tags>
      
      <tag>测试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>链表</title>
    <link href="/2023/06/27/%E9%93%BE%E8%A1%A8/"/>
    <url>/2023/06/27/%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="链表数据结构"><a href="#链表数据结构" class="headerlink" title="链表数据结构"></a>链表数据结构</h2><blockquote><p>在计算机科学中，链表是数据元素的线性集合，元素的线性顺序不是由它们在内存中的物理地址给出的。它是由一组节点组成的数据结构，每个元素指向下一个元素，这些节点一起，表示线性序列。</p></blockquote><p><img src="/2023/06/27/%E9%93%BE%E8%A1%A8/1.png" alt="链表"></p>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>设计模式</title>
    <link href="/2023/06/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <url>/2023/06/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="设计模式学习"><a href="#设计模式学习" class="headerlink" title="设计模式学习"></a>设计模式学习</h1><h2 id="设计模式简介"><a href="#设计模式简介" class="headerlink" title="设计模式简介"></a>设计模式简介</h2><blockquote><p><strong>设计模式</strong>是软件设计中常见问题的典型解决方案。 它们就像能根据需求进行调整的预制蓝图， 可用于解决代码中反复出现的设计问题。</p><p>设计模式与方法或库的使用方式不同， 你很难直接在自己的程序中套用某个设计模式。 模式并不是一段特定的代码， 而是解决特定问题的一般性概念。 你可以根据模式来实现符合自己程序实际所需的解决方案。</p><p>人们常常会混淆模式和算法， 因为两者在概念上都是已知特定问题的典型解决方案。 但算法总是明确定义达成特定目标所需的一系列步骤， 而模式则是对解决方案的更高层次描述。 同一模式在两个不同程序中的实现代码可能会不一样。</p><p>算法更像是菜谱： 提供达成目标的明确步骤。 而模式更像是蓝图： 你可以看到最终的结果和模式的功能， 但需要自己确定实现步骤。</p></blockquote><p><img src="/2023/06/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%B8%B8%E7%94%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.png" alt="常用设计模式"></p><h2 id="设计模式分类"><a href="#设计模式分类" class="headerlink" title="设计模式分类"></a>设计模式分类</h2><blockquote><ul><li><strong>创建型模式</strong>：提供创建对象的机制， 增加已有代码的灵活性和可复用性。</li><li><strong>结构型模式</strong>：介绍如何将对象和类组装成较大的结构， 并同时保持结构的灵活和高效。</li><li><strong>行为模式</strong>：负责对象间的高效沟通和职责委派。</li></ul></blockquote><p><img src="/2023/06/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/img1.png" alt="设计模式分类"></p><h3 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h3><blockquote><p><strong>工厂方法模式</strong>：一种创建型设计模式， 其在父类中提供一个创建对象的方法， 允许子类决定实例化对象的类型。</p><p>代码练习示例：<a href="https://gitee.com/kittsai/design-mode/tree/master/FactoryMode">https://gitee.com/kittsai/design-mode/tree/master/FactoryMode</a></p></blockquote><p><img src="/2023/06/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/gcfams.png" alt="工厂方法模式"></p><p><img src="/2023/06/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/gcfamsjjfa.png" alt="解决方案"></p>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>刷题系列之链表</title>
    <link href="/2023/06/12/%E5%88%B7%E9%A2%98%E7%B3%BB%E5%88%97%E4%B9%8B%E9%93%BE%E8%A1%A8/"/>
    <url>/2023/06/12/%E5%88%B7%E9%A2%98%E7%B3%BB%E5%88%97%E4%B9%8B%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><h3 id="删除排序链表中的重复元素"><a href="#删除排序链表中的重复元素" class="headerlink" title="删除排序链表中的重复元素"></a>删除排序链表中的重复元素</h3><div class="note note-info">            <p>给定一个已排序的链表的头 head ， 删除所有重复的元素，使每个元素只出现一次 。返回 已排序的链表 。</p><p>输入：head &#x3D; [1,1,2]<br>输出：[1,2]</p>          </div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 思路：</span><br><span class="hljs-comment">     * 指定一个数，找这个数的下一个数进行比较。</span><br><span class="hljs-comment">     * 如果相等，则继续找后面的数在进行比较。</span><br><span class="hljs-comment">     * 如果不相等，则重新指定当前的数，再找当前的数的下一个数进行比较。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">deleteDuplicates</span><span class="hljs-params">(ListNode head)</span> &#123;<br><br>        <span class="hljs-comment">// head 不要修改，变化的只是指针</span><br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> head;<br>        <br>        <span class="hljs-keyword">while</span> (cur != <span class="hljs-literal">null</span> &amp;&amp; cur.next != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">if</span> (cur.val == cur.next.val) &#123; <span class="hljs-comment">// 相等</span><br>                cur.next = cur.next.next;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                cur = cur.next;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br></code></pre></td></tr></table></figure><div class="note note-success">            <p>代码：<a href="https://gitee.com/kittsai/litcode/blob/master/lb/src/main/java/com/kit/Lb_1.java">https://gitee.com/kittsai/litcode/blob/master/lb/src/main/java/com/kit/Lb_1.java</a></p>          </div><h3 id="合并两个有序链表"><a href="#合并两个有序链表" class="headerlink" title="合并两个有序链表"></a>合并两个有序链表</h3><div class="note note-info">            <p>将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。</p><p>输入：l1 &#x3D; [1,2,4], l2 &#x3D; [1,3,4]<br>输出：[1,1,2,3,4,4]</p>          </div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 思路：</span><br><span class="hljs-comment">     * list1[1,2,3] 与 list2[1,2,3]</span><br><span class="hljs-comment">     * 1、比较 list1的1 和 list2的1</span><br><span class="hljs-comment">     * 2、找出来相对较小的一个数，然后拿这个list剩下的列表 与 另外一个列表比较  1 -&gt; ([2,3] 与 [1,2,3] 比较)</span><br><span class="hljs-comment">     * 1 -&gt; 1 -&gt; ([2,3] 与 [2,3] 比较)</span><br><span class="hljs-comment">     * 1 -&gt; 1 -&gt; 2 -&gt; ([3] 与 [2,3] 比较)</span><br><span class="hljs-comment">     * 1 -&gt; 1 -&gt; 2 -&gt; 2 -&gt; ([3] 与 [3] 比较)</span><br><span class="hljs-comment">     * 1 -&gt; 1 -&gt; 2 -&gt; 2 -&gt; 3 -&gt; 3</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">mergeTwoLists</span><span class="hljs-params">(ListNode list1, ListNode list2)</span> &#123;<br><br>        <span class="hljs-keyword">if</span> (list1 == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> list2;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (list2 == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> list1;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (list1.val &lt; list2.val) &#123;<br>            list1.next = mergeTwoLists(list1.next, list2);<br>            <span class="hljs-keyword">return</span> list1;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            list2.next = mergeTwoLists(list1, list2.next);<br>            <span class="hljs-keyword">return</span> list2;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><div class="note note-success">            <p>代码：<a href="https://gitee.com/kittsai/litcode/blob/master/lb/src/main/java/com/kit/Lb_2.java">https://gitee.com/kittsai/litcode/blob/master/lb/src/main/java/com/kit/Lb_2.java</a></p>          </div><h3 id="判断链表是否为环形"><a href="#判断链表是否为环形" class="headerlink" title="判断链表是否为环形"></a>判断链表是否为环形</h3><div class="note note-info">            <p>给你一个链表的头节点 head ，判断链表中是否有环。</p><p>输入：head &#x3D; [3,2,0,-4], pos &#x3D; 1<br>输出：true</p><p>输入：head &#x3D; [1,2], pos &#x3D; 0<br>输出：true</p>          </div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 思路1：</span><br><span class="hljs-comment">     * 定义一个Set 把元素循环添加到Set中，如果当前节点的值之前已经存在过，说明是环形。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasCycleMethod1</span><span class="hljs-params">(ListNode head)</span> &#123;<br><br>        Set&lt;ListNode&gt; set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br><br>        <span class="hljs-keyword">while</span> (head != <span class="hljs-literal">null</span>) &#123;<br><br>            <span class="hljs-comment">// Set add方法解释：</span><br>            <span class="hljs-comment">// 如果此集合尚未包含指定的元素，则为 true。</span><br>            <span class="hljs-comment">// 如果此集合已包含该元素，则调用将保留该集合不变并返回 false。</span><br>            <span class="hljs-keyword">if</span> (!set.add(head)) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br><br>            head = head.next;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 思路2：Floyd 判圈算法</span><br><span class="hljs-comment">     * 假想「乌龟」和「兔子」在链表上移动，「兔子」跑得快，「乌龟」跑得慢。</span><br><span class="hljs-comment">     * 当「乌龟」和「兔子」从链表上的同一个节点开始移动时，</span><br><span class="hljs-comment">     * 如果该链表中没有环，那么「兔子」将一直处于「乌龟」的前方；</span><br><span class="hljs-comment">     * 如果该链表中有环，那么「兔子」会先于「乌龟」进入环，并且一直在环内移动。</span><br><span class="hljs-comment">     * 等到「乌龟」进入环时，由于「兔子」的速度快，它一定会在某个时刻与乌龟相遇，即套了「乌龟」若干圈。</span><br><span class="hljs-comment">     * &lt;p&gt;</span><br><span class="hljs-comment">     * 我们可以根据上述思路来解决本题。</span><br><span class="hljs-comment">     * 具体地，我们定义两个指针，一快一慢。</span><br><span class="hljs-comment">     * 慢指针每次只移动一步，而快指针每次移动两步。</span><br><span class="hljs-comment">     * 初始时，慢指针在位置 head，而快指针在位置 head.next。</span><br><span class="hljs-comment">     * 这样一来，如果在移动的过程中，快指针反过来追上慢指针，就说明该链表为环形链表。否则快指针将到达链表尾部，该链表不为环形链表。</span><br><span class="hljs-comment">     * &lt;p&gt;</span><br><span class="hljs-comment">     * 我们可以假想一个在 head 之前的虚拟节点，慢指针从虚拟节点移动一步到达 head，快指针从虚拟节点移动两步到达 head.next，这样我们就可以使用 while 循环了。或者就使用do-while循环</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasCycleMethod2</span><span class="hljs-params">(ListNode head)</span> &#123;<br><br>        <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">null</span> || head.next == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br><br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">slow</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">fast</span> <span class="hljs-operator">=</span> head.next;<br><br>        <span class="hljs-keyword">while</span> (slow != fast) &#123;<br><br>            <span class="hljs-keyword">if</span> (fast == <span class="hljs-literal">null</span> || fast.next == <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br><br>            slow = slow.next; <span class="hljs-comment">// 走一步</span><br>            fast = fast.next.next; <span class="hljs-comment">// 走两步</span><br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br></code></pre></td></tr></table></figure><div class="note note-success">            <p>代码：<a href="https://gitee.com/kittsai/litcode/blob/master/lb/src/main/java/com/kit/Lb_3.java">https://gitee.com/kittsai/litcode/blob/master/lb/src/main/java/com/kit/Lb_3.java</a></p>          </div><h3 id="相交链表"><a href="#相交链表" class="headerlink" title="相交链表"></a>相交链表</h3><div class="note note-info">            <p>给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 null 。<br>题目数据 保证 整个链式结构中不存在环。<br>注意，函数返回结果后，链表必须 保持其原始结构 。<br>示例1：<br>输入：intersectVal &#x3D; 8, listA &#x3D; [4,1,8,4,5], listB &#x3D; [5,6,1,8,4,5], skipA &#x3D; 2, skipB &#x3D; 3<br>输出：Intersected at ‘8’<br>解释：相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。<br>从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,6,1,8,4,5]。<br>在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。<br>请注意相交节点的值不为 1，因为在链表 A 和链表 B 之中值为 1 的节点 (A 中第二个节点和 B 中第三个节点) 是不同的节点。换句话说，它们在内存中指向两个不同的位置，而链表 A 和链表 B 中值为 8 的节点 (A 中第三个节点，B 中第四个节点) 在内存中指向相同的位置。</p>          </div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 思路:</span><br><span class="hljs-comment">     * 如果有两个链表，分别为 [4,1,8,4,5] 和 [5,6,1,8,4,5] 在8的时候相交</span><br><span class="hljs-comment">     * 把两个链表连起来，比如链表A走到表尾的时候，指向链表B的头结点，这样就连起来了</span><br><span class="hljs-comment">     * 那么链表A 可以看作 A+B [4,1,8,4,5,5,6,1,8,4,5]</span><br><span class="hljs-comment">     * 那么链表B 可以看作 B+A [5,6,1,8,4,5,4,1,8,4,5]</span><br><span class="hljs-comment">     * 这么就可以看出 在 倒数第三位 8 的时候相交</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">getIntersectionNode</span><span class="hljs-params">(ListNode headA, ListNode headB)</span> &#123;<br><br>        <span class="hljs-keyword">if</span> (headA == <span class="hljs-literal">null</span> || headB == <span class="hljs-literal">null</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br><br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">p1</span> <span class="hljs-operator">=</span> headA, p2 = headB;<br><br>        <span class="hljs-keyword">while</span> (p1 != p2) &#123;<br>            p1 = p1 == <span class="hljs-literal">null</span> ? headB : p1.next;<br>            p2 = p2 == <span class="hljs-literal">null</span> ? headA : p2.next;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> p1;<br>    &#125;<br></code></pre></td></tr></table></figure><div class="note note-success">            <p>代码：<a href="https://gitee.com/kittsai/litcode/blob/master/lb/src/main/java/com/kit/Lb_4.java">https://gitee.com/kittsai/litcode/blob/master/lb/src/main/java/com/kit/Lb_4.java</a></p>          </div><h3 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a>反转链表</h3><div class="note note-info">            <p>题目：给你单链表的头节点 head ，请你反转链表，并返回反转后的链表。<br>示例 1：<br>输入：head &#x3D; [1,2,3,4,5]<br>输出：[5,4,3,2,1]<br>示例2：<br>输入：head &#x3D; [1,2]<br>输出：[2,1]<br>示例3：<br>输入：head &#x3D; []<br>输出：[]</p>          </div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 思路：</span><br><span class="hljs-comment">     * 1-&gt;2-&gt;3-&gt;4-&gt;5</span><br><span class="hljs-comment">     * null &lt;- 1</span><br><span class="hljs-comment">     * 1 &lt;- 2</span><br><span class="hljs-comment">     * 2 &lt;- 3</span><br><span class="hljs-comment">     * 3 &lt;- 4</span><br><span class="hljs-comment">     * 4 &lt;- 5</span><br><span class="hljs-comment">     * &lt;p&gt;</span><br><span class="hljs-comment">     * 最后为： null &lt;- 1 &lt;- 2 &lt;- 3 &lt;- 4 &lt;- 5</span><br><span class="hljs-comment">     *                                    pre</span><br><span class="hljs-comment">     * pre 指针指到最后一个 所以返回pre：5-&gt;4-&gt;3-&gt;2-&gt;1</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">reverseList</span><span class="hljs-params">(ListNode head)</span> &#123;<br><br>        <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br><br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">now</span> <span class="hljs-operator">=</span> head;<br><br>        <span class="hljs-keyword">while</span> (now != <span class="hljs-literal">null</span>) &#123;<br><br>            <span class="hljs-comment">// 先保留一下next</span><br>            <span class="hljs-type">ListNode</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> now.next;<br><br>            <span class="hljs-comment">// 当前的节点next指针往前指</span><br>            now.next = pre;<br>            <span class="hljs-comment">// pre往后移动一位</span><br>            pre = now;<br>            <span class="hljs-comment">// now往后移动一位</span><br>            now = tmp;<br><br>        &#125;<br>        <span class="hljs-keyword">return</span> pre;<br>    &#125;<br></code></pre></td></tr></table></figure><div class="note note-success">            <p>代码：<a href="https://gitee.com/kittsai/litcode/blob/master/lb/src/main/java/com/kit/Lb_5.java">https://gitee.com/kittsai/litcode/blob/master/lb/src/main/java/com/kit/Lb_5.java</a></p>          </div><h3 id="回文链表"><a href="#回文链表" class="headerlink" title="回文链表"></a>回文链表</h3><div class="note note-info">            <p>题目：给你一个单链表的头节点 head ，请你判断该链表是否为回文链表。如果是，返回 true ；否则，返回 false 。<br>示例1：<br>输入：head &#x3D; [1,2,2,1]<br>输出：true<br>示例2：<br>输入：head &#x3D; [1,2]<br>输出：false</p>          </div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 思路：首先将链表的所有值放入一个数组中，然后数组定义一个头指针和尾指针，头指针++，尾指针--，判断两个指针指向的值是否一致</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isPalindrome</span><span class="hljs-params">(ListNode head)</span> &#123;<br><br>        <span class="hljs-comment">// ArrayList 底层是数组</span><br>        List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">now</span> <span class="hljs-operator">=</span> head;<br><br>        <span class="hljs-keyword">while</span> (now != <span class="hljs-literal">null</span>) &#123;<br>            list.add(now.val);<br>            now = now.next;<br>        &#125;<br><br>        <span class="hljs-comment">// 头指针</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">front</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 尾指针</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> list.size() - <span class="hljs-number">1</span>;<br><br>        <span class="hljs-keyword">while</span> (front &lt; end) &#123;<br><br>            <span class="hljs-keyword">if</span> (!list.get(front).equals(list.get(end))) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>            front++;<br>            end--;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br></code></pre></td></tr></table></figure><div class="note note-success">            <p>代码：<a href="https://gitee.com/kittsai/litcode/blob/master/lb/src/main/java/com/kit/Lb_6.java">https://gitee.com/kittsai/litcode/blob/master/lb/src/main/java/com/kit/Lb_6.java</a></p>          </div><h3 id="设计哈希集合"><a href="#设计哈希集合" class="headerlink" title="设计哈希集合"></a>设计哈希集合</h3><div class="note note-info">            <p>题目：不使用任何内建的哈希表库设计一个哈希集合（HashSet）。</p><p>实现 MyHashSet 类：<br>void add(key) 向哈希集合中插入值 key 。<br>bool contains(key) 返回哈希集合中是否存在这个值 key 。<br>void remove(key) 将给定值 key 从哈希集合中删除。如果哈希集合中没有这个值，什么也不做。<br>示例1：<br>输入：<br>[“MyHashSet”, “add”, “add”, “contains”, “contains”, “add”, “contains”, “remove”, “contains”]<br>[[], [1], [2], [1], [3], [2], [2], [2], [2]]<br>输出：<br>[null, null, null, true, false, null, true, null, false]<br>解释：<br>MyHashSet myHashSet &#x3D; new MyHashSet();<br>myHashSet.add(1);      &#x2F;&#x2F; set &#x3D; [1]<br>myHashSet.add(2);      &#x2F;&#x2F; set &#x3D; [1, 2]<br>myHashSet.contains(1); &#x2F;&#x2F; 返回 True<br>myHashSet.contains(3); &#x2F;&#x2F; 返回 False ，（未找到）<br>myHashSet.add(2);      &#x2F;&#x2F; set &#x3D; [1, 2]<br>myHashSet.contains(2); &#x2F;&#x2F; 返回 True<br>myHashSet.remove(2);   &#x2F;&#x2F; set &#x3D; [1]<br>myHashSet.contains(2); &#x2F;&#x2F; 返回 False ，（已移除）</p>          </div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 思路：</span><br><span class="hljs-comment">     * 设计一个数组，数组的每个格里放一个链表。</span><br><span class="hljs-comment">     * 通过取模的方式判断 key 要放到数组的哪个位置，然后在对链表进行操作</span><br><span class="hljs-comment">     */</span><br><br>    <span class="hljs-comment">// 取模数 TODO 为啥必须是素数啊?</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">BASE</span> <span class="hljs-operator">=</span> <span class="hljs-number">769</span>;<br><br>    <span class="hljs-keyword">private</span> LinkedList[] list;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Lb_7</span><span class="hljs-params">()</span> &#123;<br>        list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>[BASE];<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; BASE; i++) &#123;<br>            list[i] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;Integer&gt;();<br>        &#125;<br><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">print</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> Arrays.toString(list);<br>    &#125;<br><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span> key)</span> &#123;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> hash(key);<br><br>        Iterator&lt;Integer&gt; iterator = list[m].iterator();<br><br>        <span class="hljs-keyword">while</span> (iterator.hasNext()) &#123;<br>            <span class="hljs-type">Integer</span> <span class="hljs-variable">now</span> <span class="hljs-operator">=</span> iterator.next();<br><br>            <span class="hljs-keyword">if</span> (now == key) &#123;<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br><br>        &#125;<br><br>        list[m].offerLast(key);<br><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">remove</span><span class="hljs-params">(<span class="hljs-type">int</span> key)</span> &#123;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> hash(key);<br><br>        Iterator&lt;Integer&gt; iterator = list[m].iterator();<br><br>        <span class="hljs-keyword">while</span> (iterator.hasNext()) &#123;<br>            <span class="hljs-type">Integer</span> <span class="hljs-variable">now</span> <span class="hljs-operator">=</span> iterator.next();<br>            <span class="hljs-keyword">if</span> (now == key) &#123;<br>                list[m].remove(now);<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>        &#125;<br><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">contains</span><span class="hljs-params">(<span class="hljs-type">int</span> key)</span> &#123;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> hash(key);<br><br>        Iterator&lt;Integer&gt; iterator = list[m].iterator();<br><br>        <span class="hljs-keyword">while</span> (iterator.hasNext()) &#123;<br><br>            <span class="hljs-type">Integer</span> <span class="hljs-variable">now</span> <span class="hljs-operator">=</span> iterator.next();<br>            <span class="hljs-keyword">if</span> (now == key) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 取模</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hash</span><span class="hljs-params">(<span class="hljs-type">int</span> key)</span> &#123;<br>        <span class="hljs-keyword">return</span> key % BASE;<br>    &#125;<br></code></pre></td></tr></table></figure><div class="note note-success">            <p>代码：<a href="https://gitee.com/kittsai/litcode/blob/master/lb/src/main/java/com/kit/Lb_7.java">https://gitee.com/kittsai/litcode/blob/master/lb/src/main/java/com/kit/Lb_7.java</a></p>          </div>]]></content>
    
    
    <categories>
      
      <category>刷题系列</category>
      
    </categories>
    
    
    <tags>
      
      <tag>刷题系列之链表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>刷题系列之数组</title>
    <link href="/2023/06/12/%E5%88%B7%E9%A2%98%E7%B3%BB%E5%88%97%E4%B9%8B%E6%95%B0%E7%BB%84/"/>
    <url>/2023/06/12/%E5%88%B7%E9%A2%98%E7%B3%BB%E5%88%97%E4%B9%8B%E6%95%B0%E7%BB%84/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h3 id="寻找数组的中心索引"><a href="#寻找数组的中心索引" class="headerlink" title="寻找数组的中心索引"></a>寻找数组的中心索引</h3><blockquote><p>给你一个整数数组 nums ，请计算数组的 中心下标 。</p><p>数组 中心下标 是数组的一个下标，其左侧所有元素相加的和等于右侧所有元素相加的和。</p><p>如果中心下标位于数组最左端，那么左侧数之和视为 0 ，因为在下标的左侧不存在元素。这一点对于中心下标位于数组最右端同样适用。</p><p>如果数组有多个中心下标，应该返回 最靠近左边 的那一个。如果数组不存在中心下标，返回 -1 。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findCenterIndex</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 计算所有数之和</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i : nums) &#123;<br>            sum += i;<br>        &#125;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">leftNum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;<br>            <span class="hljs-comment">// 左侧=右侧=总和-左侧-中心值</span><br>            <span class="hljs-keyword">if</span> (leftNum == (sum - leftNum - nums[i])) <span class="hljs-keyword">return</span> i;<br>            leftNum += nums[i];<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br></code></pre></td></tr></table></figure><blockquote><p>代码：<a href="https://gitee.com/kittsai/litcode/blob/master/sz/src/main/java/com/kit/Sz_1.java">https://gitee.com/kittsai/litcode/blob/master/sz/src/main/java/com/kit/Sz_1.java</a></p></blockquote><h3 id="搜索插入位置"><a href="#搜索插入位置" class="headerlink" title="搜索插入位置"></a>搜索插入位置</h3><blockquote><p>给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。<br>请必须使用时间复杂度为 O(log n) 的算法。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 使用二分查找法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">searchInsertIndex</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target)</span> &#123;<br><br>        <span class="hljs-keyword">if</span> (nums.length == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = nums.length - <span class="hljs-number">1</span>;<br><br>        <span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br><br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> (left + right) / <span class="hljs-number">2</span>;<br><br>            <span class="hljs-keyword">if</span> (nums[mid] == target) &#123;<br>                <span class="hljs-keyword">return</span> mid;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &gt; target) &#123;<br>                right = mid - <span class="hljs-number">1</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                left = mid + <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> left;<br>    &#125;<br></code></pre></td></tr></table></figure><blockquote><p>代码：<a href="https://gitee.com/kittsai/litcode/blob/master/sz/src/main/java/com/kit/Sz_2.java">https://gitee.com/kittsai/litcode/blob/master/sz/src/main/java/com/kit/Sz_2.java</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>刷题系列</category>
      
    </categories>
    
    
    <tags>
      
      <tag>刷题系列之数组</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
