<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>链表</title>
    <link href="/2023/06/27/%E9%93%BE%E8%A1%A8/"/>
    <url>/2023/06/27/%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="链表数据结构"><a href="#链表数据结构" class="headerlink" title="链表数据结构"></a>链表数据结构</h2><blockquote><p>在计算机科学中，链表是数据元素的线性集合，元素的线性顺序不是由它们在内存中的物理地址给出的。它是由一组节点组成的数据结构，每个元素指向下一个元素，这些节点一起，表示线性序列。</p></blockquote><p><img src="/2023/06/27/%E9%93%BE%E8%A1%A8/1.png" alt="链表"></p>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>设计模式</title>
    <link href="/2023/06/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <url>/2023/06/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="设计模式学习"><a href="#设计模式学习" class="headerlink" title="设计模式学习"></a>设计模式学习</h1><h2 id="设计模式简介"><a href="#设计模式简介" class="headerlink" title="设计模式简介"></a>设计模式简介</h2><blockquote><p><strong>设计模式</strong>是软件设计中常见问题的典型解决方案。 它们就像能根据需求进行调整的预制蓝图， 可用于解决代码中反复出现的设计问题。</p><p>设计模式与方法或库的使用方式不同， 你很难直接在自己的程序中套用某个设计模式。 模式并不是一段特定的代码， 而是解决特定问题的一般性概念。 你可以根据模式来实现符合自己程序实际所需的解决方案。</p><p>人们常常会混淆模式和算法， 因为两者在概念上都是已知特定问题的典型解决方案。 但算法总是明确定义达成特定目标所需的一系列步骤， 而模式则是对解决方案的更高层次描述。 同一模式在两个不同程序中的实现代码可能会不一样。</p><p>算法更像是菜谱： 提供达成目标的明确步骤。 而模式更像是蓝图： 你可以看到最终的结果和模式的功能， 但需要自己确定实现步骤。</p></blockquote><p><img src="/2023/06/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%B8%B8%E7%94%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.png" alt="常用设计模式"></p><h2 id="设计模式分类"><a href="#设计模式分类" class="headerlink" title="设计模式分类"></a>设计模式分类</h2><blockquote><ul><li><strong>创建型模式</strong>：提供创建对象的机制， 增加已有代码的灵活性和可复用性。</li><li><strong>结构型模式</strong>：介绍如何将对象和类组装成较大的结构， 并同时保持结构的灵活和高效。</li><li><strong>行为模式</strong>：负责对象间的高效沟通和职责委派。</li></ul></blockquote><p><img src="/2023/06/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/img1.png" alt="设计模式分类"></p><h3 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h3><blockquote><p><strong>工厂方法模式</strong>：一种创建型设计模式， 其在父类中提供一个创建对象的方法， 允许子类决定实例化对象的类型。</p><p>代码练习示例：<a href="https://gitee.com/kittsai/design-mode/tree/master/FactoryMode">https://gitee.com/kittsai/design-mode/tree/master/FactoryMode</a></p></blockquote><p><img src="/2023/06/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/gcfams.png" alt="工厂方法模式"></p><p><img src="/2023/06/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/gcfamsjjfa.png" alt="解决方案"></p>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>刷题系列</title>
    <link href="/2023/06/12/%E5%88%B7%E9%A2%98%E7%B3%BB%E5%88%97/"/>
    <url>/2023/06/12/%E5%88%B7%E9%A2%98%E7%B3%BB%E5%88%97/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="DAY1-寻找数组的中心索引"><a href="#DAY1-寻找数组的中心索引" class="headerlink" title="DAY1_寻找数组的中心索引"></a>DAY1_寻找数组的中心索引</h2><blockquote><p>给你一个整数数组 nums ，请计算数组的 中心下标 。</p><p>数组 中心下标 是数组的一个下标，其左侧所有元素相加的和等于右侧所有元素相加的和。</p><p>如果中心下标位于数组最左端，那么左侧数之和视为 0 ，因为在下标的左侧不存在元素。这一点对于中心下标位于数组最右端同样适用。</p><p>如果数组有多个中心下标，应该返回 最靠近左边 的那一个。如果数组不存在中心下标，返回 -1 。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findCenterIndex</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 计算所有数之和</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i : nums) &#123;<br>            sum += i;<br>        &#125;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">leftNum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;<br>            <span class="hljs-comment">// 左侧=右侧=总和-左侧-中心值</span><br>            <span class="hljs-keyword">if</span> (leftNum == (sum - leftNum - nums[i])) <span class="hljs-keyword">return</span> i;<br>            leftNum += nums[i];<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br></code></pre></td></tr></table></figure><blockquote><p>代码：<a href="https://gitee.com/kittsai/litcode/tree/master/day1">https://gitee.com/kittsai/litcode/tree/master/day1</a></p></blockquote><h2 id="DAY2-搜索插入位置"><a href="#DAY2-搜索插入位置" class="headerlink" title="DAY2_搜索插入位置"></a>DAY2_搜索插入位置</h2><blockquote><p>给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。<br>请必须使用时间复杂度为 O(log n) 的算法。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 使用二分查找法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">searchInsertIndex</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target)</span> &#123;<br><br>        <span class="hljs-keyword">if</span> (nums.length == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = nums.length - <span class="hljs-number">1</span>;<br><br>        <span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br><br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> (left + right) / <span class="hljs-number">2</span>;<br><br>            <span class="hljs-keyword">if</span> (nums[mid] == target) &#123;<br>                <span class="hljs-keyword">return</span> mid;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &gt; target) &#123;<br>                right = mid - <span class="hljs-number">1</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                left = mid + <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> left;<br>    &#125;<br></code></pre></td></tr></table></figure><blockquote><p>代码：<a href="https://gitee.com/kittsai/litcode/tree/master/day2">https://gitee.com/kittsai/litcode/tree/master/day2</a></p></blockquote><h2 id="DAY3-链表"><a href="#DAY3-链表" class="headerlink" title="DAY3_链表"></a>DAY3_链表</h2><h4 id="3-1-删除排序链表中的重复元素"><a href="#3-1-删除排序链表中的重复元素" class="headerlink" title="3-1-删除排序链表中的重复元素"></a>3-1-删除排序链表中的重复元素</h4><blockquote><p>给定一个已排序的链表的头 head ， 删除所有重复的元素，使每个元素只出现一次 。返回 已排序的链表 。</p><p>输入：head &#x3D; [1,1,2]<br>输出：[1,2]</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 思路：</span><br><span class="hljs-comment">     * 指定一个数，找这个数的下一个数进行比较。</span><br><span class="hljs-comment">     * 如果相等，则继续找后面的数在进行比较。</span><br><span class="hljs-comment">     * 如果不相等，则重新指定当前的数，再找当前的数的下一个数进行比较。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">deleteDuplicates</span><span class="hljs-params">(ListNode head)</span> &#123;<br><br>        <span class="hljs-comment">// head 不要修改，变化的只是指针</span><br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> head;<br>        <br>        <span class="hljs-keyword">while</span> (cur != <span class="hljs-literal">null</span> &amp;&amp; cur.next != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">if</span> (cur.val == cur.next.val) &#123; <span class="hljs-comment">// 相等</span><br>                cur.next = cur.next.next;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                cur = cur.next;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br></code></pre></td></tr></table></figure><blockquote><p>代码：<a href="https://gitee.com/kittsai/litcode/blob/master/day3/src/main/java/com/kit/LitCode3_1.java">https://gitee.com/kittsai/litcode/blob/master/day3/src/main/java/com/kit/LitCode3_1.java</a></p></blockquote><h4 id="3-2-合并两个有序链表"><a href="#3-2-合并两个有序链表" class="headerlink" title="3-2-合并两个有序链表"></a>3-2-合并两个有序链表</h4><blockquote><p>将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。</p><p>输入：l1 &#x3D; [1,2,4], l2 &#x3D; [1,3,4]<br>输出：[1,1,2,3,4,4]</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 思路：</span><br><span class="hljs-comment">     * list1[1,2,3] 与 list2[1,2,3]</span><br><span class="hljs-comment">     * 1、比较 list1的1 和 list2的1</span><br><span class="hljs-comment">     * 2、找出来相对较小的一个数，然后拿这个list剩下的列表 与 另外一个列表比较  1 -&gt; ([2,3] 与 [1,2,3] 比较)</span><br><span class="hljs-comment">     * 1 -&gt; 1 -&gt; ([2,3] 与 [2,3] 比较)</span><br><span class="hljs-comment">     * 1 -&gt; 1 -&gt; 2 -&gt; ([3] 与 [2,3] 比较)</span><br><span class="hljs-comment">     * 1 -&gt; 1 -&gt; 2 -&gt; 2 -&gt; ([3] 与 [3] 比较)</span><br><span class="hljs-comment">     * 1 -&gt; 1 -&gt; 2 -&gt; 2 -&gt; 3 -&gt; 3</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">mergeTwoLists</span><span class="hljs-params">(ListNode list1, ListNode list2)</span> &#123;<br><br>        <span class="hljs-keyword">if</span> (list1 == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> list2;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (list2 == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> list1;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (list1.val &lt; list2.val) &#123;<br>            list1.next = mergeTwoLists(list1.next, list2);<br>            <span class="hljs-keyword">return</span> list1;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            list2.next = mergeTwoLists(list1, list2.next);<br>            <span class="hljs-keyword">return</span> list2;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><blockquote><p>代码：<a href="https://gitee.com/kittsai/litcode/blob/master/day3/src/main/java/com/kit/LitCode3_2.java">https://gitee.com/kittsai/litcode/blob/master/day3/src/main/java/com/kit/LitCode3_2.java</a></p></blockquote><h4 id="3-3-判断链表是否为环形"><a href="#3-3-判断链表是否为环形" class="headerlink" title="3-3-判断链表是否为环形"></a>3-3-判断链表是否为环形</h4><blockquote><p>给你一个链表的头节点 head ，判断链表中是否有环。</p><p>输入：head &#x3D; [3,2,0,-4], pos &#x3D; 1<br>输出：true</p><p>输入：head &#x3D; [1,2], pos &#x3D; 0<br>输出：true</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 思路1：</span><br><span class="hljs-comment">     * 定义一个Set 把元素循环添加到Set中，如果当前节点的值之前已经存在过，说明是环形。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasCycleMethod1</span><span class="hljs-params">(ListNode head)</span> &#123;<br><br>        Set&lt;ListNode&gt; set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br><br>        <span class="hljs-keyword">while</span> (head != <span class="hljs-literal">null</span>) &#123;<br><br>            <span class="hljs-comment">// Set add方法解释：</span><br>            <span class="hljs-comment">// 如果此集合尚未包含指定的元素，则为 true。</span><br>            <span class="hljs-comment">// 如果此集合已包含该元素，则调用将保留该集合不变并返回 false。</span><br>            <span class="hljs-keyword">if</span> (!set.add(head)) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br><br>            head = head.next;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 思路2：Floyd 判圈算法</span><br><span class="hljs-comment">     * 假想「乌龟」和「兔子」在链表上移动，「兔子」跑得快，「乌龟」跑得慢。</span><br><span class="hljs-comment">     * 当「乌龟」和「兔子」从链表上的同一个节点开始移动时，</span><br><span class="hljs-comment">     * 如果该链表中没有环，那么「兔子」将一直处于「乌龟」的前方；</span><br><span class="hljs-comment">     * 如果该链表中有环，那么「兔子」会先于「乌龟」进入环，并且一直在环内移动。</span><br><span class="hljs-comment">     * 等到「乌龟」进入环时，由于「兔子」的速度快，它一定会在某个时刻与乌龟相遇，即套了「乌龟」若干圈。</span><br><span class="hljs-comment">     * &lt;p&gt;</span><br><span class="hljs-comment">     * 我们可以根据上述思路来解决本题。</span><br><span class="hljs-comment">     * 具体地，我们定义两个指针，一快一慢。</span><br><span class="hljs-comment">     * 慢指针每次只移动一步，而快指针每次移动两步。</span><br><span class="hljs-comment">     * 初始时，慢指针在位置 head，而快指针在位置 head.next。</span><br><span class="hljs-comment">     * 这样一来，如果在移动的过程中，快指针反过来追上慢指针，就说明该链表为环形链表。否则快指针将到达链表尾部，该链表不为环形链表。</span><br><span class="hljs-comment">     * &lt;p&gt;</span><br><span class="hljs-comment">     * 我们可以假想一个在 head 之前的虚拟节点，慢指针从虚拟节点移动一步到达 head，快指针从虚拟节点移动两步到达 head.next，这样我们就可以使用 while 循环了。或者就使用do-while循环</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasCycleMethod2</span><span class="hljs-params">(ListNode head)</span> &#123;<br><br>        <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">null</span> || head.next == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br><br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">slow</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">fast</span> <span class="hljs-operator">=</span> head.next;<br><br>        <span class="hljs-keyword">while</span> (slow != fast) &#123;<br><br>            <span class="hljs-keyword">if</span> (fast == <span class="hljs-literal">null</span> || fast.next == <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br><br>            slow = slow.next; <span class="hljs-comment">// 走一步</span><br>            fast = fast.next.next; <span class="hljs-comment">// 走两步</span><br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br></code></pre></td></tr></table></figure><blockquote><p>代码：<a href="https://gitee.com/kittsai/litcode/blob/master/day3/src/main/java/com/kit/LitCode3_3.java">https://gitee.com/kittsai/litcode/blob/master/day3/src/main/java/com/kit/LitCode3_3.java</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>刷题系列</category>
      
    </categories>
    
    
    <tags>
      
      <tag>刷题系列</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
